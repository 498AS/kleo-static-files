#!/usr/bin/env bun
/**
 * Generates Caddy configuration for all static file sites.
 * 
 * This script reads all sites from the SQLite database and generates
 * a Caddyfile snippet that can be imported by the main Caddyfile.
 * 
 * Usage: 
 *   bun run scripts/sync-caddy.ts              # Generate config
 *   bun run scripts/sync-caddy.ts --reload     # Generate + reload Caddy
 * 
 * Output: /etc/caddy/sites.d/static-files.caddy (configurable via SF_CADDY_SNIPPET)
 */

import { Database } from "bun:sqlite";
import { mkdirSync, writeFileSync, existsSync } from "fs";
import { dirname } from "path";
import { $ } from "bun";

// Config
const DB_PATH = process.env.SF_DB_PATH || "/var/lib/kleo-static-files/data/static-files.db";
const CADDY_SNIPPET = process.env.SF_CADDY_SNIPPET || "/etc/caddy/sites.d/static-files.caddy";
const DOMAIN = process.env.SF_DOMAIN || "498as.com";
const BIND_IPS = process.env.SF_BIND_IPS || "116.203.74.64 2a01:4f8:1c1b:8985::1";

interface Site {
  name: string;
  path: string;
  auth_user: string | null;
  auth_hash: string | null;
}

function generateCaddyConfig(sites: Site[]): string {
  const lines: string[] = [
    "# Auto-generated by kleo-static-files",
    "# Do not edit manually - changes will be overwritten",
    `# Generated: ${new Date().toISOString()}`,
    "",
  ];

  if (sites.length === 0) {
    lines.push("# No sites configured");
    return lines.join("\n");
  }

  for (const site of sites) {
    lines.push(`${site.name}.${DOMAIN} {`);
    lines.push(`    bind ${BIND_IPS}`);
    lines.push("");

    // Basic auth if configured
    if (site.auth_user && site.auth_hash) {
      lines.push("    basic_auth {");
      lines.push(`        ${site.auth_user} ${site.auth_hash}`);
      lines.push("    }");
      lines.push("");
    }

    // File server
    lines.push(`    root * ${site.path}`);
    lines.push("    file_server {");
    lines.push("        index index.html");
    lines.push("    }");
    lines.push("");

    // Logging
    lines.push("    log {");
    lines.push("        output file /var/log/caddy/sites.log {");
    lines.push("            roll_size 10mb");
    lines.push("            roll_keep 5");
    lines.push("        }");
    lines.push("    }");

    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

async function main() {
  const shouldReload = process.argv.includes("--reload");
  const dryRun = process.argv.includes("--dry-run");

  // Check if DB exists
  if (!existsSync(DB_PATH)) {
    console.error(`Database not found: ${DB_PATH}`);
    console.error("Run the server first to initialize the database.");
    process.exit(1);
  }

  // Read sites from DB
  const db = new Database(DB_PATH, { readonly: true });
  const sites = db.query<Site, []>(
    "SELECT name, path, auth_user, auth_hash FROM sites"
  ).all();
  db.close();

  console.log(`Found ${sites.length} site(s)`);

  // Generate config
  const config = generateCaddyConfig(sites);

  if (dryRun) {
    console.log("\n--- Generated config (dry run) ---\n");
    console.log(config);
    return;
  }

  // Ensure directory exists
  mkdirSync(dirname(CADDY_SNIPPET), { recursive: true });

  // Write config
  writeFileSync(CADDY_SNIPPET, config);
  console.log(`Written: ${CADDY_SNIPPET}`);

  // Reload Caddy if requested
  if (shouldReload) {
    console.log("Reloading Caddy...");
    try {
      await $`systemctl reload caddy`.quiet();
      console.log("Caddy reloaded successfully");
    } catch (e: any) {
      // Try caddy reload directly if systemctl fails
      try {
        await $`caddy reload --config /etc/caddy/Caddyfile`.quiet();
        console.log("Caddy reloaded successfully");
      } catch (e2: any) {
        console.error("Failed to reload Caddy:", e2.message);
        process.exit(1);
      }
    }
  } else {
    console.log("Run with --reload to apply changes to Caddy");
  }
}

main();
